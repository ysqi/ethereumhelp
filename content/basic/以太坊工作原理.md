---
title: "以太坊交易处理流程"
date: 2019-01-20T21:47:11+08:00
draft: false
weight: 10005
menu:
    docs:
      #identifier : ""
      parent: "basic"
---

以太坊即是一个去中心化账本，也是一个容错性强的数据库。随着时间推移、交易活动，数据库内容。
从软件工程角度上看，以太坊是一个容错性强的单实例数据库，通过交易/事务（Transaction）改变数据。

+ **容错性强**，
以太坊运行在一个点对点网络中，赋予每个节点的能力一样。
即使一个或多个节点故障，也不会影响以太坊继续工作。
+ **数据库**，
以太坊作为去中心化账本，而此账本便是一个数据库。
简而言之是电子化的文件柜，所有事务均按照一定规则存储在文件柜中。
+ **单实例**，
虽然以太坊运行在点对点网络中，但不能让数据库修改冲突

从数据角度上，以太坊是一个状态机，反映着以太坊系统从开始运行到现在时刻的变化。
状态存储着过去的信息，交易作为动作行为。
随动作执行，以太坊状态被不断变化。

图片

图一中以太坊从创世状态开始，后续每一个区块中包含了多个交易。
每笔交易打包到区块中均在接龙式改变账本状态，下一个区块的初始状态取自上一个区块打包后的状态。
最后一个区块打包后的状态就是以太坊账本的当前状态。

{{<adm type="note">}}
区块打包，表示矿工将一系列未处理交易依次执行，包含到一个新区块的过程。
也可是认为是节点收到网络中的区块，进行共识校验时的本地模拟执行过程。
{{</adm>}}

每次状态变化，都可以给此刻的状态计算出一个ID。
在以太坊中，通过将状态中存储的信息指纹作为默克尔树（Merkle Tree）的叶子，可以安全计算出所有信息的指纹，即状态根值(StateRoot)。
图一中的状态间的箭头便是通过此指纹关联，具体细节见默克尔树章节。

## 账户

那么状态中存储的信息是怎么划分的呢？以太坊引入了中心化系统中常见的账户模型。
所有信息均按照账户划分，账户间信息相互独立，互补干扰。
账户又分外部账户和合约账户：

+ 外部账户
<br>是映射到真实世界的一个账户，拥有该账户私钥的任何人都可以操作该账户。
如同现在的银行卡，到ATM机取款时只需要密码输入正确即可。
这也是人类与以太坊账本沟通唯一媒介，因为以太坊中的交易发起方只能是外部账户。
+ 合约账户
<br>合约被外部账户或者合约创建，合约在创建时均被自动分配一个账户地址，用于存储合约中的所有信息。
合约账户是通过SHA3哈希算法生成，不存在私钥。
因此任何人都无法直接利用合约账户发起交易，只能通过外部账户操作。

操作权限的区分，是以太坊交易安全的大功臣。人类保管各自的私钥来管理自己的账户，他人难以触及。
合约则可以被任何人接触。

两类账户信息不全然一样，具体见图二。合约账户比外部账户多了合约代码信息和合约代码摘要。
这是因为以太坊中执行智能合约，实际执行的是合约代码。
合约代码是通过合约代码摘要存储的。
当确定需要执行哪个合约时，将从此合约账户中根据合约代码摘要从存储中获取对应的合约代码并执行。

在信息安全中，`Nonce`是一个在加密通信中只能使用一次的数字。它往往是一个随机或伪随机数，以避免重放攻击。
账户中的 Nonce 也是用于避免重放攻击，但不是随机产生。
外部账户起始值是 0，合约账户起始值等于创建合约的账户的 Nonce 加 1，后续账户中每执行一笔交易，Nonce 值计加一次。

每笔交易必须携带 Nonce 值，只有等于当前账户信息中的 Nonce 时，交易才有效。
并在执行交易时更新 Nonce 加 1。 
这样，一笔交易不可能被执行两次，避免重放攻击。同时可视作账户执行交易次数的一个计数器。






账本记录着所有交易，而每一笔交易均必须有签名。谁在签名呢？以太坊中将能够签名的个体命名为账户。